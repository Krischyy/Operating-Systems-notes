Разписани упражнения по Операционни системи от Йордан Бабуков.

Операционни системи, упражнение 8. 

Cистемни примитиви на C за работа с файлове

1)
int open(const char *pathname, int flag[| more flags] );
първият аргумент е име на файл, който искаме да поставим в режим flag.

flags:
О_RDONLY	-> отваря файл pathname в режим на четене
O_WRONLY	-> отваря файл pathname в режим на писане
O_RDWR		-> отваря файл pathname в режим на писане и четене
O_TRUNC		-> отваря файл pathname, като му занулява съдържанието
O_APPEND	-> отваря файл pathname, като поставя указател към края на съдържанието на файла.
O_CREAT		-> създава нов файл с име pathname, ако не съществува.

2)
int close(int fd); 
затваря новозаделеният файлов дескриптор от open() към файла.

3)
ssize_t read(int fd, void *buf, size_t count);
Първият аргумент е файлов дескриптор към файл, който трябва да е отворен за четене
След което прочитаме count (третият аргумент) на брой символа, 
които се запаметяват временно в buf (вторият аргумент)

4)
ssize_t write(int fd, const void *buf, size_t count);
Първият аргумент е файлов дескриптор към файл, който трябва да е отворен за писане
След което подаваме count (третият аргумент) на брой символа за запис
Които са предварително запазени в buf (вторият аргумент)

*Най-често размера на буферите за четене и писане са с еднакви

Пример и обяснения - директно върху задачи:
Задача 1:

Копирайте съдържанието на файл1 във файл2
]$ vi task1.c
//копирайте съдържанието на файл1 във файл2
#include <fcntl.h>      //библиотека необходима за изпълнение на open
#include <stdlib.h>     //библиотека необходима за изпълнение на exit()

//argc е брой подадени входни параметри (в случая нула)
//argv се асоциира със стойностите на подадените входни параметри
//пример за достъп до 1-вия подаден входен параметър: argv[1] и тн
//пример за обхождане на всички подадени входни параметри: argv[*]
main(int argc, char* argv[]){
        int fd1;        //ще бъде асоцииран с първия файл от който ще четем
        int fd2;        //ще бъде асицииран с втория файл, в който ще пишем
        char c;         //това ще е текущо прочетения символ от първия файл, който ще записваме във втория файл.

        //системните примитив на C връщат код -1 при грешка и > от -1 при успех
        //Изключително желателно е да се прави проверка, дали файлът е отворен успешно
        //open връща цялочислена стойност, която служи за файлов дескриптор към файла
        //след успешно изпълнение на open, ще работим с файловия дескриптор, а не с името на файла!
        if ( ( fd1 = open("/home/jbabukov/file_to_read", O_RDONLY) ) == -1 ){
                //двойката в долния ред се асоциира със стандартния изход за грешки, ако беше 1, щеше да се асоциира със стандартния изход
                write(2, "File failed to open in read mode\n", 33);
                exit(-1);
        }

        if ( ( fd2 = open("/home/jbabukov/file_to_write", O_CREAT|O_WRONLY) ) == -1 ){
                write(2, "File failed to open in write mode\n", 33);
                exit(-1);
        }

        //прочитане символ по символ първия файл и като прочетем символ го записваме във втория.
        while ( read(fd1, &c, 1) ){
                write(fd2, &c, 1);
        }

        //затваряме заделените файлови дескриптори
        close(fd1);
        close(fd2);
}

Остава да си компилираме творението:

cc task1.c -o task1
сега го стартираме и се наслаждаваме на резултатите:
./task1

Задача 2:
Реализирайте команда head без опции (т.е. винаги да извежда на стандартния изход само първите 10 реда от съдържанието на файл подаден като първи параматър)

cat task2.c
#include <fcntl.h>
#include <stdlib.h>
#include <stdio.h>

main(int argc, char* argv[]){
        int fd1;
        int i=0;        //броят на символи за нов редове
        char c;

        if ( ( fd1 = open(argv[1], O_RDONLY) ) == -1 ){
                write(2, "File failed to open in read mode\n", 33);
                exit(-1);
        }

        while ( read(fd1, &c, 1) ){
                if( c == '\n' ){
                        i=i+1;
                }

                //извеждаме на стандартния изход прочетения символ
                write(1, &c, 1);

                //при достигане на 10ти символ за нов ред, приключвамe изпълнението на програмата.
                if( i == 10 ){
                        close(fd1);
                        exit(0);
                }
        }
        close(fd1);
}

Koмпилираме:
cc task2.c -o task2

и стартираме:
./task2 task1.c

Задача 3:
Реализирайте команда wc

Опростено на максимум решение на задача 3:
//Реализирайте команда wc, с един аргумент подаден като входен параметър
//По-долу е предоставен вариант на решение на задачата без проверки (във възможно най-опростен вариант)
#include <fcntl.h>
#include <stdlib.h>
#include <stdio.h>

main (int argc, char* argv[]){
        int fd1;
        char c;         //променлива, чрез която ще обхождам съдържанието на файла подаден като първи входен параметър
        int lines=0, words=0, chars=0;

        fd1 = open(argv[1], O_RDONLY);
        //Обхождам файла символ по символ и следя за разни символи, при които трябва да предприема някакво действие.
        //проверка дали успешно съм достъпил символ от съдържанието на файла.
        while( read(fd1, &c, 1) ){
                if(c=='\n'){
                        lines++;
                        words++;
                }

                if(c==' '){
                        words++;
                }

                chars++;

        }

        printf("File %s has:\n%d number of lines.\n%d number of words.\n%d number of chars.\n", argv[1], lines, words, chars);
        close(fd1);
}


По-истинско решение на задача 3:

//Реализирайте команда wc, с един аргумент подаден като входен параметър
//По-долу е предоставен вариант на решение на задачата включващ проверки.
#include <fcntl.h>
#include <stdlib.h>
#include <stdio.h>

main (int argc, char* argv[]){
        int fd1;
        char c;         //променлива, чрез която ще обхождам съдържанието на файла подаден като първи входен параметър
        int lines=0, words=0, chars=0;
        ssize_t read_size;      // Променлива, чрез която ще следя дали не настъпва грешка повреме на обхождането на съдържанието на файла.
        //Променливата е тип ssize_t, тъй като функцията read връща стойност тип ssize_t.

        /*
          проверка дали е подаден точно един входен параметър
          2 означава че имаме точно един входен параметър (другият е името на самата команда)
          Пример: ./wc wc.c
          Първят е "wc", вторият "wc.c"
        */

        if (argc != 2){
                write(2,"Йоу, wrong number of arguments!\n", 32);
                exit(1);
        }

        /*
          Oтваряне на файлa подаден като първи входен параметър в режим на четене
          и проверка дали операцията се е осъществила успешно.
        */
        if ( (fd1 = open(argv[1], O_RDONLY)) == -1 ){
                write(2, "Operation open failed!", 27);
                exit(1);
        }

        //Обхождаме файла символ по символ и следим за разни символи, при които трябва да предприемем някакво действие.
        //проверка дали успешно сме достъпили символ от съдържанието на файла.
        while( ( read_size=read(fd1, &c, 1) ) > 0 ){
                if(c=='\n'){
                        lines++;
                        words++;
                }

                if(c==' '){
                        words++;
                }

                chars++;
        }

        printf("File %s has:\n%d number of lines.\n%d number of words.\n%d number of chars.\n", argv[1], lines, words, chars);
        close(fd1);
}

