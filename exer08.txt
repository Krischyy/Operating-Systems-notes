Commands till now:
Till K1:
pwd, ls, echo, date, man, who, passwd, cat, head, tail, touch, rm, mkdir, rmdir, cp, mv, sort, cut, grep, wc, read, sleep, exit, shift
Работа с променливи, фонов режим, пренасочване на ст. вх/из/гр, конвейр, екраниращи символи.
if (сравнение на числа и на стрингове)
for, while, until

Till K2:
Още опции към оператор if: -z, -n, -f, -d, -e, -r, -w, -x
Опции към команда echo, -n, -e
Аритметични изрази с expr, expr length, expr substr, expr index
chmod, chown, ps, kill

1.
Напишете командна процедура на bash, която приема на командния си ред произволен брой аргументи.
Аргументите съответстват на съществуващи обикновени файлове и директории в текущата директория.
Нека командната процедура извежда на стандартния изход подходящо съобщение, ако подаден аргумент е файл с права за четене.
Ако подаденият аргумент е директория, да изведе на стандартния изход само файловете, които имат по-малък размер от броя на файловете в директорията.

Решение:
#обхождаме всички подадени позиционни параметри
for i in $*
do
	#проверка, дали текущия позиционен параметър е обикновен файл с права за четене
	if [ -f ./$i ] && [ -r ./$i ]
	then
		echo "$1 is file with read permissions! "
	fi
	
	#проверяваме, дали текущият параметър е директория
	if [ -d ./$i ]
	then
		#ако е директория я обхождаме
		for j in $(ls ./$i)
		do
			#проверяваме дали големите на файл е по-малка от броя на обикновените файлове в тази директория
			if [ $(wc -c < ./$i/$j ) -lt $(ls -l ./$i | grep ^- | wc -l) ]
			#$i е директорията и в нея трябва да имаме файлове, които последователно ще обхождаме с променливата $j.
			then
				echo "Some friendly output"
			fi
		done
	fi
done

2.
Напишете командна процедура на bash, която приема на командния си ред един аргумент - символен низ, съответстващ на съществуваща директория.
Нека командната процедура приканва потребителят да въведе директория, след което създава въведената от него директория във вашата home директория и копира всички обикновени файлове съдържащи се в директорията въведена от команден ред, които имат права за четене и писане в нея.

Решение:
#проверка дали е въведен точно е аргумент и дали съответства на директория се прави по желание. 
#приканваме потребителят да въведе нещо си
echo -n "Dear user, please enter directory name: "
read dir_name_entered_by_user

#създаваме директорията, спрямо изискването от условието.
mkdir ~/$dir_name_entered_by_user

#копираме обикновените файлове от директория, въведена като първи позиционен аргумент - в тази въведена от потребителя.
#за целта трябва да обходим съдържанието на $1 и за всяко едни нещо в нея да проверим дали отговаря на критериите от условието на задачата. 
for i in $(ls $1)
do
	#проверка дали е файл, права за четене (read), права за писане (write)
	if [ -f $i ] && [ -r $i ] && [ -w $i ]
	then
		#ако покрива всичките тези условия, то тогава копираме файла в директорията въведена от потребителя.
		cp $i ~/$dir_name_entered_by_user
	fi
done


3.
Да се състави командна процедура, която получава като параметри на командния си ред два символни низа - имена на същестуваща директория и на съществуващ обикновен файл.
За всеки обикновен файл от директорията да извежда по подходящ начин броя символи в него на стандартния изход, а името на всяка директория да се добавя към файла подаден като втори параметър на командната процедура.

#обхождаме директорията, като правим проверка дали е файл или е директория нейното съдържание.
for i in $(ls $1)
do
	#проверка дали е файл:
	if [ -f $i ]
	then
		#извеждам по подходящ начин броят символи на файл
		echo "File $i contains $(wc -c < $i) symbols. "
	fi 

	#проверявам дали е директория:
	if [ -d $i ]
	then
		#ако е директория.. добавям името на директорията във файл подаден като 2ри позиционен аргумент
		echo $i >> $2
	fi
done

4. 
Да се състави командна процедура, която получава като параметри на командния си ред два символни низа - имена на съществуващи директории.
Aко броят на файловете, чието име съдържа разширение ".out" в първата директория е по-голям от броя на същите във втората, изведете подходящо съобщение на стандартния изход.

#извличам всички файлове с разширение .out
first_dir_content=$(ls -l $1 | grep ^- | grep '.out'$ | wc -l)
second_dir_content=$(ls -l $2 | grep ^- | grep '.out'$ | wc -l)

#сверявам броят на файловете във всяка и спрямо сравнението предприемам някакво действие.
if [ $first_dir_content -gt $second_dir_content ]
then
	echo "First dir has more files with '.out' extension. "
fi


5.
Напишете командна процедура на bash, която приканва потребителят да въведе факултетния си номер.
Докато потребителят не въведе ФН, процедурата да продължава да го приканва.
При коректно въведен ФН, ако цифрите на десетиците е:
1, да изведе на стандартния изход "Вие сте от първа група"
2, да изведе на стандартния изход "Вие сте от втора група"
3, да изведе на стандартния изход "Вие сте от трета група"
4, да изведе на стандартния изход "Вие сте от четвърта група"

*Стойността на ФН е произволно естествено число в интервала [100, 9999]

#приканваме потребителя да въведе ФН:
echo "Dear Gerlana, please enter a faculty number: "
read fac_num

#ако не е въвела фн (фн е число от 100 до 9999)
while [ true ]
do
	#check if the entered thing is really a faculty number:
	if [ $fac_num -gt 100 -a $fac_num -lt 10000 ] 2> /dev/null
	then
		echo "Good job! "
		#if it's faculty number, leave the infinite while loop
		break
	fi
	#if it's not a faculty number, keep prompting the user to enter a faculty number..
	echo "Oh, no! You have to try again, please read the instructions"
	echo "Dear Gerlana, please enter a faculty number: "
	read fac_num
done 

#това може и с if-ове.
case $( expr $(expr $fac_num % 100) / 10 ) in
1) echo "You belong to group 1" ;;
2) echo "You belong to group 2" ;;
3) echo "You belong to group 3" ;;
4) echo "You belong to group 4" ;;
*) echo "You don't belong to any group" ;;
esac

6.
 Напишете командна процедура, която получава параметри на командния си ред списък с имена на файлове. 
За всеки обикновен файл от списъка, който съществува извежда на стандартния изход по един ред съдържащ първите 2 букви и дължината на името му.
Имената на несъществуващите файлове от списъка, добавя във файла, чието име е прочетено от стандартния вход.

#това е, заради края на задачата.
echo "Enter file at which all non-existing file names will be placed." 
read file_with_filenames

for i in $*
do
	if [ -f $i ]
	then	
		echo "File $i first two letters: $(expr substr $i 1 2), and has total name length $(expr length $i)"
	#приемаме че входните параметри са само файлове.... за да не правим проверка за символна връзка, директория, character device или block device
	else
		echo $i >> $file_with_filesnames
	fi
	
done

7.
Да се състави командна процедура, която получава в командния ред при стартиране два параметъра - първият, от които е символен низ, а вторият - число.
Ако в нашата home директория съществува директория с име съвпадащо с низа, процедурата извежда на стандартния изход имената на всички обикновени файлове в нея, които имат размер по-голям от подаденото число.
В противен случай (ако не съществува такава директория) на стандартния изход се извежда подходящо съобщение.

#проверка, дали в нашата home директория, съществува директория, името на която съвпада с първия позиционен параметър
if [ -d ~/$1 ]
then
	#ако съществува такава директория.. обхождаме я и извеждаме всички имена на обикновени файлове с размер по-голям от 2рия позиционен параметър
	for i in $(ls ~/$1)
	do
		if [ -f ~/$1/$i ] -a [ $(wc -c < ~/$1/$i) -gt $2 ]
		then
			echo "$i"
		fi
	done
else
	echo "Directory with such name does not exist in your home directory! "
fi
